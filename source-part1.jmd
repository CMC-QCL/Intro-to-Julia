# Introduction to Julia: Part I


# Agenda

1. What is Julia?
2. Basics
    - Tools and Getting Around
    - Literals, Variables, and Functions
    - Program Control Flow
3. Exercises
4. Using Other People's Code
    - Standard Library
    - Registered Packages
    - Environments
    - Modules
5. What can you do with the Julia programming language?
    - Scientific Modelling
    - Fast Linear Algebra

### Learning Goals

After this workshop you should:

1. Be familiar with Julia syntax.
2. Understand variables, functions, and basic data types in Julia.
3. Be able to write short programs in Julia.
4. Feel confident enough to explore more on your own.

# What is Julia?

> **The Julia Project as a whole is about bringing usable, scalable technical computing to a greater audience**: allowing scientists and researchers to use computation more rapidly and effectively; letting businesses do harder and more interesting analyses more easily and cheaply.
> Part of that project entails creating a free, open-source language that is as easy to use as possible, so that researchers who are not necessarily professional programmers can easily create and share programs that others will be able to use for free and improve upon.
> However, a large part of the project is also about creating an ecosystem in which such openness and sharing can take place.

-- [Julia Project page](https://julialang.org/project/)

### Why should I care?

1. It is easy to prototype *fast*, *idiomatic* code in Julia *at a high level* thanks to Julia's JIT compiler and powerful type system.
2. Julia favors a generic programming style: write functions that assume as little as possible and compose them to write powerful programs.
3. The Julia community is open and highly collaborative. Many high profile packages represent the joint effort of several brilliant people.

### How is it different from `xxxxx`?

Syntax comparison between MATLAB, Julia, and Python: https://cheatsheets.quantecon.org/
The Julia manual has a dedicated package on this: https://docs.julialang.org/en/v1/manual/noteworthy-differences/

### I like `X/Y/Z` from `xxxxx` language. I don't think I can ever switch.

Early on in the development of Julia, people put effort into building interoperability between Julia and other languages.
This means that if you really need a package implemented in another language, it is possible to use it directly from within Julia.

**Examples**

- Python: Use [PyCall.jl](https://github.com/JuliaPy/PyCall.jl). 
- R: Use [RCall.jl](https://github.com/JuliaInterop/RCall.jl).
- MATLAB: Use [MATLAB.jl](https://github.com/JuliaInterop/MATLAB.jl).
- FORTRAN or C: Use the built-in `ccall` function documented [here](https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/).
- C++: Use [Cxx.jl](https://github.com/JuliaInterop/Cxx.jl).

The [JuliaInterop](https://github.com/JuliaInterop) organization has more packages available for other languages.

**Ultimately, the Julia language is (a very useful) tool. You should use whatever makes you productive, and your work reproducible.**

# Basics

### Tools to write Julia code

Julia program files end with the `.jl` file extension.
There are two environments people generally use to write Julia code:

1. An *interactive* environment lets you input commands and gives you feedback as you work. For example, Julia comes with its own **REPL (Read-Evaluation-Print Loop)** that operates in a command line fashion. 
2. A *non-interactive* environment executes a series of commands (program) in the background without any feedback. Error messages, due to logical errors or program state, are generally handled by the program itself.

**Programs** or **scripts** are usually, but not always, non-interactive in that they are used to automate long tasks without active control from a user.

Here we will focus on how to work within a Jupyter notebook.
Much of what we do here will carry over to working in a REPL.

### Jupyter notebooks

This notebook is made up of different cells:

1. **Code cells** contain a series of instructions (in Julia). You can run them by clicking the run button, entering `Ctrl + Enter`.
2. **Markdown cells** contain text that can be formatted with [Markdown](https://jupyter-notebook.readthedocs.io/en/latest/examples/Notebook/Working%20With%20Markdown%20Cells.html). They may contain text, images, LaTeX equations.

After selecting a cell (highlighted in green):

* You can insert a new cell (code cell by default) by typing `Esc` followed by `A` (insert above) or `Esc` followed by `B` (insert below).
* Convert it to a code cell using `Esc` then `Y`.
* Convert it to a Markdown cell using `Esc` then `M`.

**Exercise**: Convert the following cell into a code cell and run it.

sqrt(2)

Another tip: You can toggle code lines with `Esc`, `L`.

### Getting Around

So far we don't really know how to do anything in Julia. Thankfully, there is a built-in help system. You can access it by entering `?`:


```julia
?
```

Note that there are four different "modes" available in both a REPL and Julia notebook:

- Default: Julia command mode.
- `?` (`help?>`): Access the help system.
- `;` (`shell>`): Access a command line shell for your system.
- `]` (`xxx pkg>`): Access Julia's package system.

You can return to the default by hitting `Delete` or `Backspace`.
A Julia REPL will tell you which mode you are in as you type a command.

You can us the help system to ask about any object defined within your working environment including data types, functions, and variables.


```julia
?print
```

The `apropos` function is also useful for finding existing commands by searching documentation for keywords.


```julia
apropos("sorting")
```

### Literals, Variables, and Basic Data Types

In most programming languages, `1`, `1.0`, and `"1"` are likely to be different kinds of objects even though they appear similar to each other.


```julia
1
```


```julia
1.0
```


```julia
"1"
```

Such objects are said to *belong to a class* or to *be of a certain type*. 
**In Julia, we think of objects in terms of types**. 

There is built-in support for various number types that are important for computing:


```julia
typeof(0x01) # 8-bit unsigned integer
```


```julia
typeof(1) # 64-bit integers, or 32-bit if you're using an older computer
```


```julia
typeof(1.0) # double precision floating point
```


```julia
typeof(1f0) # single precision floating point
```


```julia
typeof('1') # characters, only one symbol
```


```julia
typeof("1") # strings, sequence of characters
```


```julia
typeof(true) # boolean: true or false
```

Symbols like `1` and `3.14` are often referred to as *literals* because the notation itself literally bears its meaning within the language.
In contrast to literals, we can use certain symbols to define *variables*.
The general syntax is `<variable name> = <assigned value>`:


```julia
myvariable = 2.0
myothervar = 3.4; # the semicolon, ;, is used to suppress printing the result of this code cell
```


```julia
myvariable
```


```julia
myothervar
```

As with many programming languages, the symbol `=` is reserved for variable assignment.
Variables are useful because we can use them to store values to later use in an algorithm, or a sequence of steps.
Like the literals we looked at before, variables also have types depending on the object it is *bound to*:


```julia
typeof(myvariable)
```

One nice feature in Julia is its [support for Unicode characters](https://docs.julialang.org/en/v1/manual/unicode-input/) in function names and variables.
In a REPL or Jupyter notebook (using Julia), you can input special characters using tab completions.
Here are a few examples:


```julia
Œ± = 0.5; # type \alpha ‚Üí Tab
x‚ÇÅ = 42; # type x\_1 ‚Üí Tab
üçî = ["bun", "patty", "bun"]; # type \:hamburger: ‚Üí Tab
```

Try printing the values of these variables below:


```julia

```

### Everything in Julia has a return type

This includes functions, `begin ... end` blocks, `for` loops, expressions, and `if .. else` statements.
If there is no "reasonable" value to return, Julia will return `nothing`, an alias for the `Nothing` object.

```julia
nothing
```


```julia
typeof(nothing)
```


```julia
?nothing
```


```julia
c = 0.0

val = for i in 1:3 # for loops evaluate to nothing
    c += rand()
end

@show val
@show c
```

**Note**: The `@show` command is a *macro* used to quickly print the value of a variable or expression.
For example, you can think of `@show val` and shorthand for `println("val = ", val)`.

```julia
val = if c < 1 # if statements return the last value in the branch taken
    "abc"
    "def"
else
    "ghi"
    "jkl"
end

val
```

Keep this in mind as we move on to functions and control flow.

### Functions

So far, we have *literals* to represent basic units of computation and *variables* to store values within a program.
These are the nouns in a programming language.
How do we actually say anything useful?
We need *functions*, which serve as verbs.

#### Built-in functions

Many useful functions are already implemented in Julia.
In fact, if there is something you want to do it is often helpful to try looking up `?<verb>` to see if an existing function can solve your task.

##### Printing (note that the character `\n` indicates a newline):

```julia
print("The value of myvariable is ", myvariable, ".\n")
print("The value of myothervar is ", myothervar, ".\n")
```

The same can be achieved with `println`:


```julia
println("The value of myvariable is ", myvariable, ".")
println("The value of myothervar is ", myothervar, ".")
```

Multi-line strings, `"""..."""`, interpret whitespace.
The `$` symbol can be used to interpolate a variable's value into a string.
More generally, `$(ex)` will interpolate the value of an expression `ex`.


```julia
print(
"""
The value of myvariable is $myvariable.
1 + 1 is $(1 + 1).
"""
)
```

##### The usual [artihmetic operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Arithmetic-Operators) are supported in Julia:

```julia
1 + 1 # addition
```


```julia
2.3 * 4 # multiplication
```


```julia
9 / 3 # (floating point) division
```


```julia
7 % 2 # remainder after integer division
```


```julia
2 ^ 4 # exponentiation
```


```julia
-1 # negative sign
```

##### Other [logical operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Boolean-Operators) and [comparison operators](https://docs.julialang.org/en/v1/manual/mathematical-operations/#Numeric-Comparisons):


```julia
1 < 2 & 2 < 2 # parantheses not needed
```


```julia
!(1 ‚â§ 1) # type `\le` and hit `TAB` to get the ‚â§ symbol
```

**Note:** The terms *operator* and *function* are virtually the same for our purposes.
The only meaningful distinction from our POV is that *operators* have shorthand names based on punctuation marks whereas *functions* are typically spelled out in several characters.
Binary operators also support *infix notation* so we can use them just how one typically writes down math but it's also possible to call operators the same way one invokes `println`:


```julia
+(1, 1)
```

#### User-defined functions

Programming involves building up many small programs that, ideally, can be composed to write larger more complex programs.
There are many ways to define a function in Julia.
For example, consider the function $x \mapsto x + 1$ that takes a number and adds 1 to it:

```julia
f(x) = x+1    # written as a single line

function f(x) # written as multiple lines
    x+1
end
```

**Aside** Notice that a few words in the definition are highlighted.
The words `function` and `end` are highlighted *purple* because they are **reserved words** -- notation that the Julia programming language reserves for the language itself.
We can understand the syntax as follows:
- `function`: begin a statement (possibly multiple lines) that defines a function.
- `end`: mark the end of the last statement.
There are many more reserved words, listed here in the [Julia documentation](https://docs.julialang.org/en/v1/base/base/#Keywords).

Getting back to function definitions, the general syntax is

```julia
function FUNCTION_NAME(INPUTS_SEPARATED_BY_COMMAS)
    # function body
end
```

By default, a function returns the value of the last statement within the body.
You can be specific about what the return value should be by using the `return` keyword.

**Exercise**: What is the return value of the following functions?

```julia
function fun1(x)
    x + 1
    x + 2
    x + 3
end
```

```julia
function fun2(x)
    x + 1
    return x + 2
    x + 3
end
```

```julia
function fun3(x)
    x + 1
    x = x + 2
    return x + 3
    x = x + 4
end
```

```julia
function fun4(x)
    x + 10
    return
    x - 2
end
```

#### Exercises

Write a function that evaluates the quadratic $a x^{2} + b x + c$.
Your function should take four (4) inputs, `a`, `b`, `c`, and `x`.

```julia
function eval_quadratic(a, b, c, x)
    return a * x ^ 2 + b * x + c
end
```

A few test cases:

```julia
@show eval_quadratic(0, 0, 2.0, 100.0)   # == 2
@show eval_quadratic(1.0, 0, 0, 10.0)    # == 100
@show eval_quadratic(0, 1.0, 0, 10.0)    # == 10
@show eval_quadratic(2, 1, -10, 2)       # 0 
```

Write a function that computes both roots of a quadratic,
$$
a x^{2} + b x + c = 0 \iff x = \frac{-b \pm \sqrt{b^{2} - 4 a c}}{2a}
$$
Your function should take three (3) inputs, `a`, `b`, and `c`, which you may assume are numbers of the same type.
You can also assume $|a| > 0$.
Return the roots as a tuple; e.g. `return root1, root2` or `return (root1, root2)`.

```julia
function quadratic(a, b, c)
    # check for real roots
    d = b^2 - 4a * c
    if d < 0
        error("Roots are not real. Use quadratic(Complex(a), Complex(b), Complex(c)) for imaginary roots.")
    end

    # compute roots
    r1 = (-b - sqrt(d)) / (2*a)
    r2 = (-b + sqrt(d)) / (2*a)

    return r1, r2
end
```

A few test cases:

```julia
@show quadratic(1.0, -2.0, 1.0) # == (1.0, 1.0); x^2 - 2x + 1
@show quadratic(1.0, 0, -1.0)   # == (-1.0, 1.0); x^2 - 1
```

#### A note for scientists

Try the following code using your `quadratic` function

```julia
a = 1.0; b = 100.0; c = 1.0
r1, r2 = quadratic(a, b, c)
@show eval_quadratic(a, b, c, r1)
@show eval_quadratic(a, b, c, r2)
```

Depending on how you chose to implement your function, one of the results above is not $0$ but close to it.
In this case, $b^{2}$ is much larger compared to $4ac$ which means $b^{2} - 4ac$ is subject to *roundoff error*.
This happens because numbers on the real line *cannot* be represented exactly on a computer.
It is an issue for irrational numbers like $\sqrt{2}$ and even rational numbers like $1/10 = 0.1$:

```julia
bitstring(0.1) # this is not exact in base 2!
```

Julia uses the [IEEE 754-2008 standard](https://en.wikipedia.org/wiki/IEEE_754-2008) to handle floating-point arithmetic.
The Julia manual has plenty of [references](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Background-and-References) for the interested reader. 

Some useful values and functions to know about:

- `Inf`/`Inf32`/`Inf16`: Literals for representing infinity.
- `0.0` and `-0.0`: Signed zeros. note that `0.0 == -0.0`.
- `NaN`: Not a Number; used to handle numerical issues like division by `0` or loss of precison due to underflow/overflow.
- `exponent`: Return the exponent in the floating point representation of a number.
- `significand`: Return the digits in the floating point representation of a number.
- `signbit`: Check the sign bit of a number (false for positive, true for negative).
- `bitstring`: Return the binary representation of a number literal.
- `eps`: Machine epsilon; the gap between `1.0` and the next largest representable value of the same numeric type.
- `nextfloat`/`prevfloat`: The next/previous representable floating-point number relative to an input.

**Takeaway**: Try to look through documentation to see if a function you want has already been implemented, *especially* for any numerics.

#### What happens when we mix data types?

Notice that `1 + 1` returns `2` as an `Int64` whereas as `4 / 2` returns `2` as a `Float64`.
We can try a few more examples to see that *addition on two elements of the same type* always returns an answer of that same type (in fact, this is a mathematical property of addition on certain sets).

Julia has a set of promotion rules to determine how to resolve certain operations.
For example, `1 + 3.2` will return `4.2` as a `Float64`.
Test this yourself using `typeof`.


```julia
# your code here
```

This is not the case with division and so we naturally have a few ways to handle it: `/`, `div`, and `//`.
Check the documentation for these functions.


```julia
# your code here
```

Julia's type promotion rules make it is so programmers do not waste time casting objects to 'compatible' data types; they are already compatible.
Importantly, operations with numbers already handle type promotion with reasonable defaults so that standard arithmetic "just works" out of the box.

However, if you ever needed to handle conversions explicitly you can do it with the `convert` function:


```julia
convert(Complex{Float64}, 1.0) # specify the type, then give the object to convert
```

### Program Control Flow

*Conditional statements* and *repeated evaluation* are common patterns that emerge in algorithms.
Julia handles these concepts in a straightforward way.

#### Conditional Statements

`if-else` blocks allow you to execute a block of code conditional on some requirement.


```julia
if rand() < 0.5 # mimic a coin flip
    println("Heads")
else
    println("Tails")
end
```

These statements can be changed using `if-elseif-else` blocks.
Remember that code blocks always have a return value.


```julia
u = rand()

x = if u < 0.25
    1
elseif 0.25 ‚â§ u < 0.5
    2
elseif 0.5 ‚â§ u < 0.75
    3
else
    4
end

println("The value of x is $(x).")
```

You can omit the `elseif` or `else` portions altogether.
These blocks can be written as one-liners, too.

What is the return type when we do assignment like this?
Use `@show x` to investigate.


```julia
x = if rand() < 0.5 "In the if statement" end

@show x
```

The ternary operator (3-argument) `?` can be used to write `if-else` statements more compactly as

`<condition> ? <true branch> : <false branch>`


```julia
truth_value = rand() < 0.5

truth_value ? println("branch taken if true") : println("branch taken if false")

@show truth_value
```

Lastly, the [short-circuit operators](https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation), `&&` and `||`, can also be used to write compact conditional statements.
Statements chained with these operators are evaluated left to right.

* Short-circuit AND (`&&`): In `a && b`, `b` is evaluted only when `a` returns `true`.
* Short-circuit OR (`||`): In `a || b`, `b` is evaluated only when `a` returns `false`.

For example, in the Julia documentation there is an example that uses them to implement a recursive version of a factorial function. 


```julia
function fact(n::Int) # ::Int is a type annotation; we'll discuss this later
    n >= 0 || error("n must be non-negative") # use || to detect a violated condtion
    n == 0 && return 1 # use && to detect the base case
    n * fact(n-1) # otherwise, continue to recurse
end
```


```julia
fact(0)
```


```julia
fact(-1)
```


```julia
fact(4)
```

#### Repeated evaluation with loops

`for` loops in Julia allow you to repeat a set of instructions a specific number of times.
For example, the following code prints out a sequence of numbers:


```julia
for i = 1:10 # this is MATLAB/FORTRAN/C/C++ -like style
    println("The value of i is $(i)")
end
```

We start by giving some condition that determines how many times to execute commands, in this case we define a *local* variable `i` and state that it will take values from `1` to `10` using the range object `1:10` (will discuss later).
Next, we give a command to execute repeatedly.
The `for` loop will run until it exhausts values in the "enumeration".

Another way is to pass a list and iterate over the elements of that list.


```julia
mylist = collect(1:10) # creates a 1-D array with elements 1 through 10; discuss later!

for item in mylist # or for i in 1:10; this is the preferred style in Julia
    println("The value of item is $(item)")
end
```

You can use `enumerate` to grab both the index and member at the same time:


```julia
mylist = rand('a':'z', 10)

for (i, item) in enumerate(mylist)
    println("The item at index $(i) is $(item)")
end
```

For loops will even work with dictionaries (discussed later!):


```julia
d = Dict('a' => 1, 'b' => 2, 'c' => 100)
```


```julia
for (key, value) in d
    println("The key $(key) maps to $(value)")
end
```

#### Exercise

Implement the factorial function using a `for` loop.

```julia
function fact2(n::Int)
    val = one(n)
    for i = n:-1:2
        val = val * i
    end
    return val
end
```

Compare against the recursive version `fact` defined earlier, and the Julia standard `factorial`.

```julia
fact(21)
```

```julia
fact2(21)
```

```julia
factorial(21)
```

The `while` loops allows one to execute repeated evaluation without knowing how many times to run a set of instructions ahead of time.
Instead of iterating over a set of values, a `while` loop runs until some condition evaluates to `false`:


```julia
counter = 0

while counter < 5
    println("The current value is $(counter)")
    counter = counter + 1 # or counter += 1
end
```


```julia
counter = 0
still_true = true # use a Bool as a flag to indicate current state

while still_true
    println("The current value is $(counter)")
    counter = counter + 1    # make sure to update the counter
    still_true = counter < 5 # make sure to update the variable we use to check
end
```

Care must be taken to make sure a `while` loop eventually terminates.
If you accidentally make an infinite `while` loop, just use the "Interrupt the kernel" button (‚ñ°), `Esc` ‚Üí `C`, or `Ctrl + C`.

#### Exercises

Credit: [Algorithms from THE BOOK](https://locus.siam.org/doi/book/10.1137/1.9781611976175?mobileUi=0&) by Kenneth Lange

The ancients could compute square roots long before the age of computers or the rigorous formulation of the real numbers.
The so-called Babylonian method estimates square roots via the iterative method
$$
x_{k+1} = \frac{1}{2}\left[x_{k} + \frac{a}{x_{k}}\right].
$$

Implement a function that computes the square root of an a non-negative number `a` based on an initial guess `x0`.
Your function should run until it achieves a given relative tolerance, $\epsilon$ = `tol`; in symbols this is
$$
|x_{k+1} - x_{k}| < \epsilon~(x_{k} + 1).
$$
Your function should also report the number of iterations taken, and return the estimate.


```julia
function babylonian(a, x0, tol)
    x_cur = x0            # current estimate
    x_old = x0            # previous estimate
    not_converged = true  # flag that indicates convergence
    iter = 0              # number of iterations
    
    # your code goes here
    while not_converged
        x_old = x_cur
        x_cur = 0.5 * (x_cur + a / x_cur)
        not_converged = abs(x_cur - x_old) ‚â• tol * (x_old + 1)
        iter += 1
    end
    
    println("Converged after $(iter) iterations.")
    
    return x_cur
end
```


```julia
x_babylonian = babylonian(2, 1.4, 1e-6)
```


```julia
x_sqrt = sqrt(2)
```


```julia
abs(x_babylonian - x_sqrt)
```

Try computing the square root of `0.0` or `0` using your implementation.

```julia

```

Write a function that counts the number of times a character `char` occurs in a given string `str`.
It should treat the upper and lower case characters as being the same; e.g. 'c' and 'C' count as the same letter.
**Hint**: Julia allows aribtrary objects to implement some notion of *iteration* and *indexing*.
A `String` object is both iterable (so that `for c in str` makes sense) and indexable (so that `str[1]`).

```julia
function countin(char, str)
    n = 0
    for c in str    
        if lowercase(c) == lowercase(char)
            n += 1
        end
    end
    return n
end
```

You can use the following function to help you test your implementation.
It converts "this" into "tHis".

```julia
function mockify(str)
    output = ""
    for (i, c) in enumerate(str)
        if i % 2 == 0
            output *= uppercase(c)
        else
            output *= lowercase(c)
        end
    end

    return output
end
```

```julia
test_string = "The quick brown fox jumps over the lazy dog."
countin('a', test_string) # should equal 1
```

```julia
countin('o', mockify(test_string)) # should equal 4
```


# Using Other People's Code

#### Standard Library

Julia ships with its own standard library.
The functions immediately available mostly live in the Base module.
Other useful packages include: 

- LinearAlgebra, for everything linear algebra
- DelimitedFiles, for working with formatted files (e.g. tab or comma separated)
- Statistics, many standard statistics functions
- Random, random number generation
- Printf, for printing formatted strings (C-style)
- Pkg, the Julia pacakge manager

#### Registered Packages

Julia users and developers are free to contribute to the Julia package ecosystem by registering them.
The **General** registry belongs to the whole community, but it is also possible to create your own private registry that contains your own packages (hosting is a separate issue).

Regardless, you can manage community-contributed packages using the Pkg module.

Some examples include:

* DifferentialEquations
* Distributions
* DataFrames
* BenchmarkTools

and many, many more.

Here are a few tips for package management:

- Commands with Pkg and `]` (pkg-mode) are equivalent.
- `Pkg.add("Example")` or `] add Example` will add the Example package to your *environment*.
- `Pkg.status()` or `] status` will tell you the list of installed packages for the current environment.
- `Pkg.remove("Example")` removes a package.
- `Pkg.activate("path/to/dir")` will activate the environment at `path/to/dir`. Julia searches the specified folder for a `Project.toml` file, or uses an empty one if it does not exist.
- Use `Pkg.activate(".")` to return to the default environment.

#### Environments

The list of explicitly installed packages is stored in a file called `Project.toml`.
The main environment is usually called `v1.x` where `x` is the minor Julia version and lives in `~/.julia/environments/v1.x`.
This is important because it helps you reproduce the environment used in developing a project!

#### How to Actually Use Packages

Packages live inside [*modules*](https://docs.julialang.org/en/v1/manual/modules/). They are defined using module code blocks.


```julia
module MyExample
    println("This module is loading")
    helloworld() = println("Hello world! This is my contribution.") # define a function
    println("We're done")

    export helloworld # export the function by default so others can use it
end
```

We see the code executed. Let's try calling the function we made:

```julia
helloworld()
```


This fails because we've not loaded the module, only defined it.
You can use `import` to load it:

```julia
import Main.MyExample # MyExample is defined in the Main scope, so we need to address it
```

```julia
helloworld()
```

This still fails? The reason is `import` tells us to load the module, but prevents exported functions from being brought into scope. We have to be explicit about where the function comes from in this case.


```julia
Main.MyExample.helloworld()
```

This can be a bit tedious, so fortunately Julia lets us bind a module to a variable to make it easier to write:


```julia
ME = Main.MyExample
```

```julia
ME.helloworld()
```

Alternatively, the `using` keyword brings all exported functions into scope:


```julia
using Main.MyExample
```

```julia
helloworld()
```

Yet another option: You can explicitly choose which functions to bring into scope when you ivoke `using`:


```julia
using LinearAlgebra: norm # only bring norm into scope, unqualified
```

```julia
norm(rand(3))
```

```julia
eigen # lives in LinearAlgebra
```

```julia
using LinearAlgebra
```

```julia
eigen
```


# What can I do with the Julia programming language?

### Scientific Modeling

**Credit**: [epirecipes](https://github.com/epirecipes/sir-julia/blob/master/markdown/ode/ode.md)

OrdinaryDiffEq.jl is part of the SciML ecosystem.
See the [organization's website](https://sciml.ai/) for more details.
DifferentialEquations.jl is the main package with lots of extra features at the cutting edge of scientific machine learning.

The following code implements a [Susceptible-Infected-Removed (SIR) model](https://github.com/epirecipes/sir-julia) for infectious diseases.
- Infected individuals spread disease through 'contact' with susceptibles.
- The rate at which individuals are infected is proportional to the proportion of infecteds in a population; it depends on an infection risk per contact, $\beta$, and an average contact rate, $c$.
- Infecteds recover at a rate $\gamma > 0$, with $1/\gamma$ denoting an average recovery time.


```julia
using OrdinaryDiffEq, Plots

function sir_ode!(du, u, p, t)
    (S, I, R) = u
    (Œ≤, c, Œ≥) = p
    N = S+I+R
    @inbounds begin
        du[1] = -Œ≤*c*I/N*S
        du[2] = Œ≤*c*I/N*S - Œ≥*I
        du[3] = Œ≥*I
    end
    nothing
end

# Initial conditions
u0 = [990.0,10.0,0.0]; # S,I.R

# Model parameters
p = [0.05,10.0,0.25]; # Œ≤,c,Œ≥

# Timespan
Œ¥t = 0.1
tmax = 40.0
tspan = (0.0,tmax)
t = 0.0:Œ¥t:tmax

# Create ODE problem and solve it
prob_ode = ODEProblem(sir_ode!, u0, tspan, p)
sol = solve(prob_ode, Tsit5())

# Plot the solution
plot(sol, xlabel="time, t", ylabel="population, u(t)", label=["S" "I" "R"], legend=:outerright)
```

### Fast Linear Algebra

[BLAS](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) and [LAPACK](https://en.wikipedia.org/wiki/LAPACK) are important libraries for carrying out *fast and correct* linear algebra operations on computers.
There are various implementations written in 'low-level' languages like C or Fortran, sometimes tuned for specific hardware, dating back to 1979.

Developers in Julia are exploring the possibility of implementing linear algebra subroutines within the Julia language.
The following compares the default BLAS implementation (OpenBLAS) shipped with Julia against [Octavian.jl](https://github.com/JuliaLinearAlgebra/Octavian.jl).
A more detailed look (with different hardware) can be found [here](https://github.com/JuliaLinearAlgebra/Octavian.jl/issues/24#issuecomment-763704038).

Run a separate Julia process using the `linalg.jl` script.
It takes in two arguments, # BLAS threads and matrix size. 
```julia
run(`/home/alanderos/julia-1.6.1/bin/julia --project=@. linalg.jl 10 1000`)
```

Run a separate Julia process using the `octavian.jl` script.
It requires you specify the number of threads (`-t 10`; match to # physical cores) and matrix size (`1000`).
```julia
run(`/home/alanderos/julia-1.6.1/bin/julia --project=@. -t 10 octavian.jl 1000`)
```

```julia
versioninfo(verbose=true)
```

**Note**: OpenBLAS may not always be able to detect the correct architecture until it is updated, and so it will default to the next best available subroutines.
[The codename Prescott dates back to Intel's Pentium 4 from the 00s](https://ark.intel.com/content/www/us/en/ark/products/codename/1791/prescott.html).
In reality the gap may be closer than reported here.

**Note**: Many programming languages for statistics, data science, or other technical computing use a BLAS implementation like OpenBLAS (R for example).

```julia
using LinearAlgebra
BLAS.openblas_get_config()
```
